[
  {
    "objectID": "example_1.html",
    "href": "example_1.html",
    "title": "Example #1",
    "section": "",
    "text": "Dash Apps\nThe examples in folder_dash are the standard demo apps. They can be run from the command line and are served through local host\n ➜  python_dash git:(main) ✗ python3 data_table_py_callback.py\nDash is running on http://127.0.0.1:8050/\n\n * Serving Flask app 'data_table_py_callback'\n * Debug mode: on\n\nIt looks like this and seems to work as expected:\n\n\n\nPython App with Callbacks\n\n\n\n\nDash within Quarto\nRunning a Dash app within Quarto was possible with ugly hacks but it isn’t pretty. May not work properly and is not supported. Simply a code exploration to be ignored. Kept in the same way that a journal of negative results is a good thing.\nWhen Dash server is running on localhost it looks like this:\n\n\n\nDash within Quarto\n\n\nie. is squashed within the page\n\n\nShow Code\n\n\n# Import packages\nfrom dash import Dash, html, dash_table, dcc, callback, Output, Input\nimport pandas as pd\nimport plotly.express as px\n\n# Incorporate data\n#df = pd.read_csv('https://raw.githubusercontent.com/plotly/datasets/master/gapminder2007.csv')\n\n# Initialize the app\napp = Dash(__name__)\n\n# App layout\napp.layout = html.Div([\n    html.Div(children='My First App with Data, Graph, and Controls'),\n    html.Hr(),\n    dcc.RadioItems(options=['pop', 'lifeExp', 'gdpPercap'], value='lifeExp', id='controls-and-radio-item'),\n    dash_table.DataTable(data=pd.read_csv('https://raw.githubusercontent.com/plotly/datasets/master/gapminder2007.csv').to_dict('records'), page_size=6),\n    dcc.Graph(figure={}, id='controls-and-graph')\n])\n\n# Add controls to build the interaction\n@callback(\n    Output(component_id='controls-and-graph', component_property='figure'),\n    Input(component_id='controls-and-radio-item', component_property='value')\n)\ndef update_graph(col_chosen):\n    import plotly.express as px\n    import pandas as pd\n    fig = px.histogram(pd.read_csv('https://raw.githubusercontent.com/plotly/datasets/master/gapminder2007.csv').to_dict('records'), x='continent', y=col_chosen, histfunc='avg')\n    return fig\n\n\n\nif __name__ == '__main__': app.run(debug=True) # Run the app"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Dash, Observable etc.",
    "section": "",
    "text": "Some thoughts\nThe purpose here is to investigate the current status of Dash, Observable and similar interactive technologies for data exploration and presentation. There are normally many options, opinions, often fluffy requirements, pros and cons that need to be considered in deciding which one(s) to use, if at all. Not least is the structure of the organization: who is tasked with performing the data analysis or data science? Dynamic plotting and easy accessibility is nice to have, but serious analysis often requires detailed data investigations (domain specific knowledge, careful validation of data, imputation of missing values, normalizations, transformations, statistical hypothesis tests, mathematics, modelling and so on). With this in mind, it is always good to ask why such tools are being deployed? Is it not better for the domain expert to learn some practical data science (or vice versa) or is the team approach better; having the subject domain experts work closely with the data science experts is probably the best option in terms of developing results, conclusions and decisions efficiently.\nBack in the day, we used Common Gateway Interface (CGI) Perl scripts on the web-server (cgi-bin/) to access a back end database in order to give dynamic access to structured data: this often required rendering bespoke images as gifs and overlaying clickable regions with html codes. Every dynamic action required a trip from the client web-browser through the 2 tiers of servers and that often required much coding work and optimization at various levels to construct a responsive application. Nevertheless, those solutions felt clunky in comparison with plethora of current solutions that are visually more appealing, functional and faster.\nAnd there are lots of current possibilities:\nThis is an article that covers some (but not all) of the current options:\ndata-dashboarding-streamlit-vs-dash-vs-shiny-vs-voila\nExample types\nExample #1 is with Dash\n\nDash is available for Python, but not yet ready for R at the time of writing\n\nExample #2 and #3 work with Observable\nShiny Examples\nMy preference is to view functionality and code of with the stock Shiny examples within RStudio and the gallery provides inspiration.\n# the standard examples are available with the Shiny library\nlibrary(shiny)\nrunExample(\"01_hello\")      # a histogram\nrunExample(\"02_text\")       # tables and data frames\nrunExample(\"03_reactivity\") # a reactive expression\nrunExample(\"04_mpg\")        # global variables\nrunExample(\"05_sliders\")    # slider bars\nrunExample(\"06_tabsets\")    # tabbed panels\nrunExample(\"07_widgets\")    # help text and submit buttons\nrunExample(\"08_html\")       # Shiny app built from HTML\nrunExample(\"09_upload\")     # file upload wizard\nrunExample(\"10_download\")   # file download wizard\nrunExample(\"11_timer\")      # an automated timer\nMy Quarto Dashboard examples are available as a separate repository and at the same time a mash-up of using R, Python within the same script(s) was evaluated.\nStreamlit, Voila, Panel are new to me…definitely on the “to do” list"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About me"
  }
]